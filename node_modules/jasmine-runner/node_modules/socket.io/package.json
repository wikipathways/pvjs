{
  "name": "socket.io",
  "description": "The cross-browser WebSocket",
  "version": "0.6.0",
  "author": {
    "name": "LearnBoost"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/learnboost/Socket.IO-node/raw/master/README.md"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/learnboost/Socket.IO-node.git"
  },
  "engine": [
    "node >=0.1.102"
  ],
  "main": "./index",
  "scripts": {
    "test": "make test"
  },
  "readme": "Socket.IO Server: Sockets for the rest of us\n============================================\n\nThe `Socket.IO` server provides seamless supports for a variety of transports intended for realtime communication\n\n- WebSocket \n- WebSocket over Flash (+ XML security policy support)\n- XHR Polling\n- XHR Multipart Streaming\n- Forever Iframe\n- JSONP Polling (for cross domain)\n\n## Requirements\n\n- Node v0.1.103+\n- [Socket.IO client](http://github.com/LearnBoost/Socket.IO) to connect from the browser\n\n## How to use\n\nTo run the demo:\n\n\tgit clone git://github.com/LearnBoost/Socket.IO-node.git socket.io\n\tcd socket.io/example/\n\tsudo node server.js\n\nand point your browser to http://localhost:8080. In addition to 8080, if the transport `flashsocket` is enabled, a server will be initialized to listen to requests on the port 843.\n\n### Implementing it on your project\n\n`Socket.IO` is designed not to take over an entire port or Node `http.Server` instance. This means that if you choose your HTTP server to listen on the port 80, `socket.io` can intercept requests directed to it and the normal requests will still be served.\n\nBy default, the server will intercept requests that contain `socket.io` in the path / resource part of the URI. You can change this (look at the available options below).\n\n\tvar http = require('http'), \n\t\t\tio = require('./path/to/socket.io'),\n\t\t\t\n\tserver = http.createServer(function(req, res){\n\t\t// your normal server code\n\t\tres.writeHeader(200, {'Content-Type': 'text/html'});\n\t\tres.writeBody('<h1>Hello world</h1>');\n\t\tres.finish();\n\t});\n\t\n\tserver.listen(80);\n\t\t\t\n\t// socket.io, I choose you\n\tvar socket = io.listen(server);\n\t\n\tsocket.on('connection', function(client){\n\t  // new client is here!\n\t  client.on('message', function(){ … })\n\t  client.on('disconnect', function(){ … })\n\t});\n\t\nOn the client side:\n\n\t<script src=\"/socket.io/socket.io.js\"></script>\n\t<script>\n\t\tvar socket = new io.Socket();\n\t\tsocket.on('connect', function(){ … })\n\t\tsocket.on('message', function(){ … })\n\t\tsocket.on('disconnect', function(){ … })\n\t</script>\n\nThe [client side](http://github.com/learnboost/socket.io) files will be served automatically by `Socket.IO-node`.\n\n## Documentation\n\n### Listener\n\n\tio.listen(<http.Server>, [options])\n\t\nReturns: a `Listener` instance\n\t\nPublic Properties:\n\n- *server*\n\n\tThe instance of _process.http.Server_\n\t\n- *options*\n\n\tThe passed in options combined with the defaults\n\t\n- *clients*\n\t\n\tAn object of clients indexed by their session ids.\n\t\nMethods:\n\n- *addListener(event, λ)*\n\n\tAdds a listener for the specified event. Optionally, you can pass it as an option to `io.listen`, prefixed by `on`. For example: `onClientConnect: function(){}`\n\t\n- *removeListener(event, λ)*\t\n\n\tRemove a listener from the listener array for the specified event.\n\t\n- *broadcast(message, [except])*\n\n\tBroadcasts a message to all clients. There's an optional second argument which is an array of session ids or a single session id to avoid broadcasting to.\n\t\nOptions:\n\t\n- *resource*\n\n\t\tsocket.io\n\n  The resource is what allows the `socket.io` server to identify incoming connections by `socket.io` clients. Make sure they're in sync.\n\n- *transports*\n\n\t\t['websocket', 'server-events', 'flashsocket', 'htmlfile', 'xhr-multipart', 'xhr-polling']\n\t\t\n\tA list of the accepted transports.\n\t\n- *transportOptions*\n\t\n\tAn object of options to pass to each transport. For example `{ websocket: { closeTimeout: 8000 }}`\n\t\n- *log*\n\t\n\t\tƒ(){ sys.log }\n\t\t\n\tThe logging function. Defaults to outputting to stdout through `sys.log`\n\nEvents:\n\t\n- *clientConnect(client)*\n\t\n\tFired when a client is connected. Receives the Client instance as parameter\n\t\n- *clientMessage(message, client)*\n\n\tFired when a message from a client is received. Receives the message and Client instance as parameter\n\t\n- *clientDisconnect(client)*\n\n\tFired when a client is disconnected. Receives the Client instance as parameter\n\nImportant note: `this` in the event listener refers to the `Listener` instance.\n\n### Client\n\t\n\tClient(listener, req, res)\n\t\nPublic Properties:\n\n- *listener*\n\n\tThe `Listener` instance this client belongs to.\n\n- *connected*\n\n\tWhether the client is connected\n\t\n- *connections*\n\n\tNumber of times the client connected\n\t\nMethods:\n\n- *send(message)*\n\n\tSends a message to the client\n\t\n- *broadcast(message)*\n\n\tSends a message to all other clients. Equivalent to Listener::broadcast(message, client.sessionId)\n\n## Protocol\n\nOne of the design goals is that you should be able to implement whatever protocol you desire without `Socket.IO` getting in the way. `Socket.IO` has a minimal, unobtrusive protocol layer. It consists of two parts:\n\n* Connection handshake\n\t\n\tThis is required to simulate a full duplex socket with transports such as XHR Polling or Server-sent Events (which is a \"one-way socket\"). The basic idea is that the first message received from the server will be a JSON object that contains a session id that will be used for further communication exchanged between the client and the server. \n\t\n\tThe concept of session also benefits naturally full-duplex WebSocket, in the event of an accidental disconnection and a quick reconnection. Messages that the server intends to deliver to the client are cached temporarily until the reconnection.\n\t\n\tThe implementation of reconnection logic (potentially with retries) is left for the user. By default, transports that are keep-alive or open all the time (like WebSocket) have a timeout of 0 if a disconnection is detected.\n\t\n* Message batching\n\n\tIn order to optimize the resources, messages are buffered. In the event of the server trying to send multiple messages while the client is temporarily disconnected (eg: xhr polling), messages are stacked, then encoded in a lightweight way and sent to the client whenever he becomes available.\n\nDespite this extra layer, your messages are delivered unaltered to the different event listeners. You can JSON.stringify() objects, send XML, or maybe plain text.\n\n## Credits\n\n- Guillermo Rauch &lt;guillermo@learnboost.com&gt; ([Guille](http://github.com/guille))\n\n- Arnout Kazemier ([3rd-Eden](http://github.com/3rd-Eden))\n\n## License \n\n(The MIT License)\n\nCopyright (c) 2010 LearnBoost &lt;dev@learnboost.com&gt;\n\nPermission is hereby granted, free of charge, to any person obtaining\na copy of this software and associated documentation files (the\n'Software'), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish,\ndistribute, sublicense, and/or sell copies of the Software, and to\npermit persons to whom the Software is furnished to do so, subject to\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
  "readmeFilename": "README.md",
  "_id": "socket.io@0.6.0",
  "_from": "socket.io@0.6.0"
}
